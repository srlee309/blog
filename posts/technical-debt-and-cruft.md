---
title: Technical debt and cruft
description: A look at the differences between technical debt and cruft. The solutions for resolving them, why technical debt is natural and cruft should be avoided
tags: Software development
publishedDate: 30/1/2020
published: true
---

# Technical debt and cruft

As developers and software development teams, we must be vigilant to ensure that the quality of our code base remains high. The difficult aspect of doing this is that it requires teams to continually allocate some portion of their time to refactoring and improving the existing code. Like with entropy, technical debt naturally accrues over time and developers need to take some time to clean it up. This time can be hard to justify because the outcome of it isn't visible and it doesn't sound good to stakeholders, it doesn't introduce new functionality and its impact is only seen in the long term. In the short term, in fact, there is a cost to it as it takes time to write high quality code as seen in the below [graph](https://martinfowler.com/articles/is-quality-worth-cost.html).

<img class="nx-jangular-blog-centered-image" src="/assets/velocity-and-code-quality.png">

The impact of low quality code is insidious. It is not easily visible in the short term, but it accumulates. This is because low quality code is hard to understand and refactor and this makes it more likely for any new changes related to it to also be of low quality as the new code must workaround or work with the low-quality code.

When looking at code quality it is important to make a distinction between two separate, but related terms: [technical debt and cruft (poorly written code)](https://www.youtube.com/watch?v=pqeJFYwnkjE).

Technical debt is produced when you aim for rapid delivery, not the sake of meeting a deadline, but to elicit quick feedback which provides the data necessary to adjust the design to be more congruent with the actual needs. Technical debit is payed back through code refactoring as an understanding of the domain matures.

> Although immature code may work fine and be completely acceptable to the customer, excess quantities will make a program unmasterable, leading to extreme specialization of programmers and finally an inflexible product. ... A little debt speeds development so long as it is paid back promptly with a rewrite ... Every minute spent on not-quite-right code counts as interest on that debt. Entire engineering organizations can be brought to a stand-still under the debt load of an unconsolidated implementation - [Ward Cunningham](http://c2.com/doc/oopsla92.html)

Technical debt is different to poorly written code. For example, although legacy code is technical debt it was probably right for the time and could have been well written code. An important thing to realise is that all code accrues technical debt and becomes a growing burden over time (it must be understood and maintained from time to time). Code becomes technical debt as the domain changes, new technologies come out or your understanding of the domain improves.

Cruft, on the other hand, is primarily about code that was never good. Cruft is generated when you are aiming for rapid delivery, not to illicit feedback, but for the sake of meeting a deadline. Cruft is about sacrificing future productivity to improve current productivity. It is generated by attempting to sacrifice quality to improve delivery time and would involve things like skipping unit testing, working in silos and making decisions on the fly about ambiguous requirements.

Cruft can be split into a few further different types as seen in the below [diagram](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html). If we consider both cruft and technical debt to be types of debt, then prudence in regards to this debt is choosing to take on the debt after considering the current benefits versus the future costs. Being deliberate or inadvertent in regards to this debt would be whether you were aware that the code you were writing is cruft.

<img class="nx-jangular-blog-centered-image" src="/assets/cruft-technical-debt-quadrant.png">

Examples:

- Reckless and deliberate would be being aware of good design processes, but not following them. It is reckless because it is done without considering the costs that will be accrued in the future from the cruft. A common cause of this is outsourcing or getting someone to work on a project for a short period of time. This is often a problem because it causes people to have no emotional attachment to the project or its quality. Since they won't be involved with maintaining it they just want to get it done and move onto the next thing as quickly as possible. This means that they don't go to the effort of writing the code properly. For example, someone might say: "can we just get this in and we will fix it up later"
- Reckless and inadvertent would be writing poor quality code due to being unaware of the best practices. This is often due to inexperience.
- Prudent and deliberate would be rushing to get a release out, but considering the costs involved with doing so and choosing to do it anyway. A team may know about good design practices, even be capable of practicing them, but decide to go "quick and dirty" because they think they can't afford the time required to write clean code. This often occurs due to management dysfunctions which lead to too much pressure being placed on developers to deliver code by a specific, often extremely rushed, deadline. For example, someone might say: "we must ship now and deal with the consequences later"
- prudent and inadvertent would be following the best practices and writing high quality code, but through the process of writing the code learning a better way to design it. Programming is a process of learning. Therefore, inadvertently as we further develop code we find that the earlier code has become technical debt. For example, someone might say: "I know the team did a good job, but I now realize that the design could have been better".

The concept of technical debt shows that even the best teams will have some debt to deal with as a project progresses. Debt. however, accrues over time, therefore, teams should be careful not to recklessly overload it with crummy code (cruft). Cruft should be minimised and to enable this developers should be:

- empowered and given time to ensure the quality of the code stays at high levels
- trained so that they know how to design well and write high quality code
- made aware of the importance of maintaining the quality of the code base and that it is everyone's responsibility
- not expecting to be able to fix it later. Some companies build without quality and then drop everything to “fix” quality later. This is a flawed approach as it leads to code cleanup being seen as a chore, hence, it often doesn't happen. Also, people often greatly overestimate their ability to fix quality issues later. As we are developing, we are also thinking about the domain and developing a contextual understanding about the problem we are solving. This contextual understanding is in large part what allows us to design and write quality code. If you move onto something else and then come back to it, that contextual understanding is largely lost and has to be regained by reviewing and reading the code. This takes time and effort and the difficulty of doing this is exacerbated if you need to look over multiple portions of the code at the same time.

Cleaning up technical debt and cruft is best done frequently. Larger issues can be raised under tasks, but in general the best way to remove technical debt and cruft is the boy scout rule which in the context of code means: leave the code a little better than when you found it. If every developer left the code base a little cleaner and a little better factored than when they found it, then the code base would be trending in a positive direction. This is a very important aspect of sustainable long-lived code bases. They get better over time rather than slowly atrophying over time because developers clean up little issues when they find them.

Following the boy scout rule or continual refactoring has an extra benefit as well. It improves the code in the places where the developers are making changes. This means that the code base gets better in places that have highest churn which is precisely where the risk is the highest. Changes are where bugs are introduced. It is also the part of the code that is least likely for those bugs to picked up as it hasn't yet been run in production by real users.
